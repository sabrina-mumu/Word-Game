from sqlalchemy import Column, Integer, String, Sequence, ForeignKey, create_engine, inspect, Boolean
from sqlalchemy.orm import sessionmaker, declarative_base, relationship
from sqlalchemy.exc import SQLAlchemyError
from dotenv import load_dotenv, find_dotenv
import os

# Declarative base
Base = declarative_base()

# Ensure the .env file is found and loaded
if not find_dotenv():
    raise FileNotFoundError("Environment file (.env) not found. Please create it.")

# Load environment variables from the .env file
load_dotenv()

# Retrieve credentials and database URL from environment
DEV_NAME = os.getenv("DEV_NAME")
DEV_PASSWORD = os.getenv("DEV_PASSWORD")
DATABASE_URL = os.getenv("DATABASE_URL")

# Check that all critical environment variables were loaded
if not all([DEV_NAME, DEV_PASSWORD, DATABASE_URL]):
    raise EnvironmentError("Critical environment variables are missing.")


class DuplicateUserError(Exception):
    """Custom exception raised when a duplicate user is detected in the database."""

    def __init__(self, message="The user name already exists"):
        self.message = message
        super().__init__(self.message)

# Define the GameResult table
class GameResult(Base):
    """Represents a game result entry in the database."""

    __tablename__ = 'sim_score'
    pid = Column(Integer, Sequence('result_id_seq'), primary_key=True)  # Primary Key
    ai_word = Column(String(50))  # AI Word
    human_word = Column(String(50))  # Human Word
    score = Column(Integer)  # Similarity Score
    checkpoints = relationship("Checkpoint", back_populates="game_result")


class UsedWords(Base):
    """Represents used words by a user within a game session."""

    __tablename__= 'used_words'
    id= Column(Integer, Sequence('used_word_id_seq'), primary_key= True)
    uid= Column (String(50))
    given_ai_word= Column(String(50))
    game_status = relationship("GameStatus", back_populates="used_word")


class Checkpoint(Base):
    """Represents a checkpoint for a specific game state for a user."""

    __tablename__= 'checkpoint'
    checkpoint_id= Column(Integer, Sequence('checkpoint_id_seq'), primary_key= True)
    uid= Column (String(50))
    pid = Column(Integer, ForeignKey('sim_score.pid'))
    game_result = relationship("GameResult", back_populates="checkpoints")


class GameStatus(Base):
    """Represents the status of a game for a user, including round information."""

    __tablename__ = 'user_level'
    id = Column(Integer, Sequence('game_status_id_seq'), primary_key=True)
    uid = Column(String(50), ForeignKey('used_words.uid'))  # Foreign key to UsedWords table
    round_count = Column(Integer, default=1)  # Indicates if the first round is over
    used_word = relationship("UsedWords", back_populates="game_status")


class GameResultDB:
    """Handles interactions with the database, including saving and retrieving game results, 
    user progress, checkpoints, and other game-related data.
    """

    def __init__(self, db_url='sqlite:///word-game.db'):
        """Initialize the database connection and session.
        
        Args:
            db_url (str): The URL of the database to connect to.
        """
        dev_name = os.getenv("DEV_NAME")
        dev_password = os.getenv("DEV_PASSWORD")
        db_url = os.getenv("DATABASE_URL")

        if dev_name and dev_password:
            self.engine = create_engine(db_url, pool_size=10, max_overflow=20, pool_timeout=30)
            self.Session = sessionmaker(bind=self.engine)
        else:
            raise ValueError("Environment credentials are missing. Access denied.")

    def create_table(self):
        """Creates all tables defined in the declarative base if they don't already exist."""
        Base.metadata.create_all(self.engine)
        inspector = inspect(self.engine)
        print(f"Tables in the database: {inspector.get_table_names()}")
        print(f"Database engine URL: {self.engine.url}")

    def get_session(self):
        """Return a new session to interact with the database.
        
        Returns:
            Session: A new session object for database transactions.
        """
        return self.Session()
    
    def save_game_result(self, ai_word: str, human_word: str, score: int):
        """Saves a game result entry to the database.
        
        Args:
            ai_word (str): Word generated by AI.
            human_word (str): Word entered by the human user.
            score (int): Score indicating similarity.
        
        Returns:
            int: Primary key of the newly created GameResult entry.
        """
        session = self.get_session()
        try:
            new_result = GameResult(ai_word=ai_word, human_word=human_word, score=score)
            session.add(new_result)
            session.commit()
            session.refresh(new_result)
            return new_result.pid
        except Exception as e:
            session.rollback()
            print(f"Error saving game result: {e}")
            return None
    
    def save_game_status(self, user_id):
        """Saves or initializes game status for a user.
        
        Args:
            user_id (str): User ID for whom game status is being saved.
        """
        session = self.get_session()
        try:
            game_status_entry = GameStatus(uid=user_id)
            session.add(game_status_entry)
            session.commit()
            print(f"Saved game status for user '{user_id}' with initial round count of {game_status_entry.round_count}")
        except Exception as e:
            session.rollback()
            print(f"Error saving game status: {e}")

    def authenticate_user(self, user_id):
        """Checks if a user exists in the database and raises a DuplicateUserError if found.
        
        Args:
            user_id (str): User ID to check.
        
        Returns:
            bool: True if user does not exist; raises DuplicateUserError if user exists.
        """
        session = self.get_session()
        try:
            existing_entry = session.query(GameStatus).filter_by(uid=user_id).first()
            if existing_entry:
                raise DuplicateUserError(f"User '{user_id}' already has a game status entry.")
            return True
        finally:
            session.close()

    def save_used_word(self, user_id, ai_word):
        """Saves a word used by a user in the game session.
        
        Args:
            user_id (str): User ID.
            ai_word (str): Word used by the AI.
        """
        session = self.get_session()
        try:
            used_word_entry = UsedWords(uid=user_id, given_ai_word=ai_word)
            session.add(used_word_entry)
            session.commit()
            print(f"Saved used word '{ai_word}' for user '{user_id}'")
        except Exception as e:
            session.rollback()
            print(f"Error saving used word: {e}")

    def save_thrown_word(self, user_id, thrown_word):
        """Saves a word that was 'thrown' or removed by a user.
        
        Args:
            user_id (str): User ID.
            thrown_word (str): Word thrown by the user.
        
        Returns:
            bool: True if word was saved successfully, False otherwise.
        """
        session = self.get_session()
        try:
            used_word_record = UsedWords(uid=user_id, given_ai_word=thrown_word)
            session.add(used_word_record)
            session.commit()
            return True
        except Exception as e:
            session.rollback()
            print(f"Error saving thrown word: {e}")
            return False
            
    def save_checkpoint(self, user_id, game_result_id):
        """Saves a checkpoint for a user based on a game result.
        
        Args:
            user_id (str): User ID.
            game_result_id (int): GameResult ID.
        """
        session = self.get_session()
        try:
            checkpoint_record = Checkpoint(uid=user_id, pid=game_result_id)
            session.add(checkpoint_record)
            session.commit()
            print(f"Saved checkpoint for user '{user_id}' with game result ID '{game_result_id}'")
        except Exception as e:
            session.rollback()
            print(f"Error saving checkpoint: {e}")

    def check_existing_score(self, ai_word, human_word):
        """Checks if a game result with the specified AI and human word already exists.
        
        Args:
            ai_word (str): AI-generated word.
            human_word (str): User-provided word.
        
        Returns:
            tuple: (pid, score) if exists, otherwise (None, None).
        """
        session = self.get_session()
        try:
            existing_result = session.query(GameResult).filter_by(ai_word=ai_word, human_word=human_word).first()
            if existing_result:
                return existing_result.pid, existing_result.score
            return None, None
        except Exception as e:
            print(f"Error checking existing score: {e}")
            return None, None

    def get_used_words_by_user_id(self, user_id):
        """Fetches words used by a specific user.
        
        Args:
            user_id (str): User ID.
        
        Returns:
            list: List of used words.
        """
        session = self.get_session()
        try:
            used_words = session.query(UsedWords).filter_by(uid=user_id).all()
            return [word.given_ai_word for word in used_words]
        except Exception as e:
            print(f"Error fetching used words for user {user_id}: {e}")
            return []

    def get_previous_results(self):
        """Retrieve all previous game results.
        
        Returns:
            list: List of GameResult objects.
        """
        session = self.get_session()
        try:
            return session.query(GameResult).all()
        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Database error occurred while retrieving previous results: {str(e)}")

    def increment_round_count(self, user_id):
        """Increments the round count for a specific user.
        
        Args:
            user_id (str): User ID.
        
        Returns:
            str: Message indicating success or failure.
        """
        session = self.get_session()
        try:
            game_status = session.query(GameStatus).filter_by(uid=user_id).first()
            if game_status:
                game_status.round_count += 1
                session.commit()
                return f"Incremented round_count to {game_status.round_count} for user {user_id}"
            else:
                return f"No GameStatus entry found for user {user_id}"
        except SQLAlchemyError as e:
            session.rollback()
            raise SQLAlchemyError(f"Error incrementing round_count: {str(e)}")
        finally:
            session.close()

    def get_round_count(self, user_id):
        """Gets the round count for a specific user.
        
        Args:
            user_id (str): User ID.
        
        Returns:
            int or str: Round count or message if no entry is found.
        """
        session = self.get_session()
        try:
            game_status = session.query(GameStatus).filter_by(uid=user_id).first()
            if game_status:
                return game_status.round_count
            else:
                return f"No GameStatus entry found for user {user_id}"
        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Error retrieving round_count: {str(e)}")
        finally:
            session.close()

    def delete_user_entries(self, user_id):
        """Deletes all entries related to a user from UsedWords, Checkpoint, and GameStatus.
        
        Args:
            user_id (str): User ID.
        
        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        session = self.get_session()
        try:
            session.query(UsedWords).filter_by(uid=user_id).delete()
            session.query(Checkpoint).filter_by(uid=user_id).delete()
            session.query(GameStatus).filter_by(uid=user_id).delete()
            session.commit()
            print(f"Deleted all entries for user '{user_id}' from UsedWords and Checkpoint tables.")
        except Exception as e:
            session.rollback()
            print(f"Error deleting entries for user '{user_id}': {e}")
            return False
        return True
    
    def clear_used_words_by_user_id(self, user_id):
        """Deletes all used words for a specific user.
        
        Args:
            user_id (str): User ID.
        
        Returns:
            bool: True if deletion was successful, False otherwise.
        """
        session = self.get_session()
        try:
            session.query(UsedWords).filter_by(uid=user_id).delete()
            session.commit()
            print(f"Cleared all used words for user '{user_id}'.")
        except Exception as e:
            session.rollback()
            print(f"Error clearing used words for user '{user_id}': {e}")
            return False
        return True

    def check_checkpoint_entry(self, user_id, ai_word, human_word):
        """Checks if a checkpoint entry exists for a specific user and game result.
        
        Args:
            user_id (str): User ID.
            ai_word (str): AI-generated word.
            human_word (str): User-provided word.
        
        Returns:
            bool: True if checkpoint exists, otherwise False.
        """
        session = self.get_session()
        try:
            game_result = session.query(GameResult).filter_by(ai_word=ai_word, human_word=human_word).first()
            if not game_result:
                print(f"No game result found for AI word '{ai_word}' and human word '{human_word}'.")
                return False
            checkpoint_entry = session.query(Checkpoint).filter_by(uid=user_id, pid=game_result.pid).first()
            return checkpoint_entry is not None
        except Exception as e:
            print(f"Error checking checkpoint entry for user '{user_id}': {e}")
            return False
